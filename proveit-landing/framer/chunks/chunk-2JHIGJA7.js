// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project d37f32ec1bb98c5f "ProveIt (Ver 404)", do not edit manually */
// /:https://framerusercontent.com/modules/6wAE2eMb2Tl3zrU7u4UL/HPzg2Uk7mwtBmDzvGbWF/Search.js
import { jsx as _jsx3, jsxs as _jsxs3 } from "react/jsx-runtime";
import { createPortal } from "react-dom";
import { useRef as useRef3, useState as useState4, useEffect as useEffect4, forwardRef as forwardRef2 } from "react";
import { AnimatePresence, motion as motion3 } from "unframer";

// /:https://framerusercontent.com/modules/LV9trClbmNwd5PVj9l8y/L4rFqMGNzGSwRZpGTGF3/Icons.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { motion } from "unframer";
function SearchIcon(props) {
  return /* @__PURE__ */ _jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 256", width: props.width, height: props.height, style: { ...props.style, color: props.color }, children: /* @__PURE__ */ _jsx("path", { d: "M232.49,215.51,185,168a92.12,92.12,0,1,0-17,17l47.53,47.54a12,12,0,0,0,17-17ZM44,112a68,68,0,1,1,68,68A68.07,68.07,0,0,1,44,112Z", fill: "currentColor" }) });
}
function ClearIcon(props) {
  return /* @__PURE__ */ _jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 256", ...props, children: [/* @__PURE__ */ _jsx("rect", { width: "256", height: "256", fill: "none" }), /* @__PURE__ */ _jsx("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm37.66,130.34a8,8,0,0,1-11.32,11.32L128,139.31l-26.34,26.35a8,8,0,0,1-11.32-11.32L116.69,128,90.34,101.66a8,8,0,0,1,11.32-11.32L128,116.69l26.34-26.35a8,8,0,0,1,11.32,11.32L139.31,128Z", fill: "currentColor" })] });
}
function SpinnerIcon(props) {
  const borderWidth = 3;
  return /* @__PURE__ */ _jsxs("div", { style: { position: "relative", ...props.style }, children: [/* @__PURE__ */ _jsx(motion.div, { animate: { rotate: 360 }, transition: { ease: "linear", duration: 1, repeat: Infinity }, style: { borderRadius: 100, backgroundImage: `conic-gradient(from 270deg, transparent 0%, ${props.color} 100%)`, width: "100%", height: "100%" } }), /* @__PURE__ */ _jsx("div", { style: { backgroundColor: props.backgroundColor, borderRadius: 100, position: "absolute", top: borderWidth, left: borderWidth, bottom: borderWidth, right: borderWidth } })] });
}

// /:https://framerusercontent.com/modules/6wAE2eMb2Tl3zrU7u4UL/HPzg2Uk7mwtBmDzvGbWF/Search.js
import { addPropertyControls, ControlType, RenderTarget, withCSS } from "unframer";

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import { jsx as _jsx2, jsxs as _jsxs2 } from "react/jsx-runtime";

// /:https://framerusercontent.com/modules/MyBp84Z0p9nUcMimVMnY/y5F4AGWJ6syeuoB7ebKM/useSearch.js
import { useLocaleInfo } from "unframer";
import { clamp } from "unframer";
import { useEffect, useMemo, useState } from "react";

// /:https://framerusercontent.com/modules/3Xi2AslpcDRhfyCVPmx3/d0Oobr5BHnVqZJQyMdGn/storage.js
function Storage(name) {
  this.ready = new Promise((resolve, reject) => {
    var request = window.indexedDB.open(location.origin);
    request.onupgradeneeded = (e) => {
      this.db = e.target["result"];
      this.db.createObjectStore("store");
    };
    request.onsuccess = (e) => {
      this.db = e.target["result"];
      resolve();
    };
    request.onerror = (e) => {
      this.db = e.target["result"];
      reject(e);
    };
  });
}
Storage.prototype.get = function(key) {
  return this.ready.then(() => {
    return new Promise((resolve, reject) => {
      var request = this.getStore().get(key);
      request.onsuccess = (e) => resolve(e.target.result);
      request.onerror = reject;
    });
  });
};
Storage.prototype.getStore = function() {
  return this.db.transaction([
    "store"
  ], "readwrite").objectStore("store");
};
Storage.prototype.set = function(key, value) {
  return this.ready.then(() => {
    return new Promise((resolve, reject) => {
      var request = this.getStore().put(value, key);
      request.onsuccess = resolve;
      request.onerror = reject;
    });
  });
};
Storage.prototype.delete = function(key, value) {
  window.indexedDB.deleteDatabase(location.origin);
};

// /:https://framer.com/m/cache-YMiL.js@b9aplVZjN51x28yfNK16
async function setCachedData(url, dataToCache, cache = new Storage("cache")) {
  const cacheKey = url;
  const data = await cache.set(cacheKey, dataToCache);
}
async function checkForCachedData(url, cache = new Storage("cache")) {
  const cacheKey = url;
  const data = await cache.get(cacheKey);
  if (data) {
    return data;
  } else {
    return null;
  }
}

// /:https://framerusercontent.com/modules/uU1mtMKXsrVAg8N5hW7w/PCK1x1QLNluYNoEoapwx/cachedIndex.js
var VERSION = 1;
function isDefaultLocaleId(localeId) {
  return !localeId || localeId === "default";
}
var INDEX_KEY = "searchIndexCache";
function getIndexKey(localeId) {
  if (isDefaultLocaleId(localeId)) return INDEX_KEY;
  return `${INDEX_KEY}-${localeId}`;
}
var METADATA_KEY = "searchCacheMetadata";
function getMetadataKey(localeId) {
  if (isDefaultLocaleId(localeId)) return METADATA_KEY;
  return `${METADATA_KEY}-${localeId}`;
}
async function getCachedIndex(localeId) {
  const indexKey = getIndexKey(localeId);
  const cachedIndex = await checkForCachedData(indexKey);
  if (cachedIndex) {
    return cachedIndex;
  }
}
function setCachedIndex(localeId, index) {
  const indexKey = getIndexKey(localeId);
  setCachedData(indexKey, index);
  const metadata = { version: VERSION, timestamp: Date.now() };
  const metadataKey = getMetadataKey(localeId);
  setCachedData(metadataKey, metadata);
}

// /:https://framerusercontent.com/modules/K9JZRwJcE6slDAf8rUmh/mJ54py1Ecnn1RoC4N1m4/fakeResults.js
var fakeResults = { "/": { version: 1, title: "Example Search Result", description: "Description of search result.", keywords: "", h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], p: [], url: "/example-url/", codeblock: [] }, "/example-1": { version: 1, title: "Publish your Site to Search", description: "Try Site Search to instantly search your Framer site content.", keywords: "", h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], p: [], url: "/example-url/1/", codeblock: [] }, "/example-2": { version: 1, title: "Customise your Site Search", description: "Personalize everything from corner radius, to icon weight.", keywords: "", h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], p: [], url: "/example-url/2/", codeblock: [] } };

// /:https://framerusercontent.com/modules/TwRgbWuhHeB95MPifel4/YW8Hlm59FG3PajbrVsaR/fuzzySearch.js
var peq = new Uint32Array(65536);
var myers_32 = (a, b) => {
  const n = a.length;
  const m = b.length;
  const lst = 1 << n - 1;
  let pv = -1;
  let mv = 0;
  let sc = n;
  let i = n;
  while (i--) {
    peq[a.charCodeAt(i)] |= 1 << i;
  }
  for (i = 0; i < m; i++) {
    let eq = peq[b.charCodeAt(i)];
    const xv = eq | mv;
    eq |= (eq & pv) + pv ^ pv;
    mv |= ~(eq | pv);
    pv &= eq;
    if (mv & lst) {
      sc++;
    }
    if (pv & lst) {
      sc--;
    }
    mv = mv << 1 | 1;
    pv = pv << 1 | ~(xv | mv);
    mv &= xv;
  }
  i = n;
  while (i--) {
    peq[a.charCodeAt(i)] = 0;
  }
  return sc;
};
var myers_x = (b, a) => {
  const n = a.length;
  const m = b.length;
  const mhc = [];
  const phc = [];
  const hsize = Math.ceil(n / 32);
  const vsize = Math.ceil(m / 32);
  for (let i = 0; i < hsize; i++) {
    phc[i] = -1;
    mhc[i] = 0;
  }
  let j = 0;
  for (; j < vsize - 1; j++) {
    let mv = 0;
    let pv = -1;
    const start = j * 32;
    const vlen = Math.min(32, m) + start;
    for (let k = start; k < vlen; k++) {
      peq[b.charCodeAt(k)] |= 1 << k;
    }
    for (let i1 = 0; i1 < n; i1++) {
      const eq = peq[a.charCodeAt(i1)];
      const pb = phc[i1 / 32 | 0] >>> i1 & 1;
      const mb = mhc[i1 / 32 | 0] >>> i1 & 1;
      const xv = eq | mv;
      const xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
      let ph = mv | ~(xh | pv);
      let mh = pv & xh;
      if (ph >>> 31 ^ pb) {
        phc[i1 / 32 | 0] ^= 1 << i1;
      }
      if (mh >>> 31 ^ mb) {
        mhc[i1 / 32 | 0] ^= 1 << i1;
      }
      ph = ph << 1 | pb;
      mh = mh << 1 | mb;
      pv = mh | ~(xv | ph);
      mv = ph & xv;
    }
    for (let k1 = start; k1 < vlen; k1++) {
      peq[b.charCodeAt(k1)] = 0;
    }
  }
  let mv1 = 0;
  let pv1 = -1;
  const start1 = j * 32;
  const vlen1 = Math.min(32, m - start1) + start1;
  for (let k2 = start1; k2 < vlen1; k2++) {
    peq[b.charCodeAt(k2)] |= 1 << k2;
  }
  let score = m;
  for (let i2 = 0; i2 < n; i2++) {
    const eq1 = peq[a.charCodeAt(i2)];
    const pb1 = phc[i2 / 32 | 0] >>> i2 & 1;
    const mb1 = mhc[i2 / 32 | 0] >>> i2 & 1;
    const xv1 = eq1 | mv1;
    const xh1 = ((eq1 | mb1) & pv1) + pv1 ^ pv1 | eq1 | mb1;
    let ph1 = mv1 | ~(xh1 | pv1);
    let mh1 = pv1 & xh1;
    score += ph1 >>> m - 1 & 1;
    score -= mh1 >>> m - 1 & 1;
    if (ph1 >>> 31 ^ pb1) {
      phc[i2 / 32 | 0] ^= 1 << i2;
    }
    if (mh1 >>> 31 ^ mb1) {
      mhc[i2 / 32 | 0] ^= 1 << i2;
    }
    ph1 = ph1 << 1 | pb1;
    mh1 = mh1 << 1 | mb1;
    pv1 = mh1 | ~(xv1 | ph1);
    mv1 = ph1 & xv1;
  }
  for (let k3 = start1; k3 < vlen1; k3++) {
    peq[b.charCodeAt(k3)] = 0;
  }
  return score;
};
var distance = (a, b) => {
  if (a.length < b.length) {
    const tmp = b;
    b = a;
    a = tmp;
  }
  if (b.length === 0) {
    return a.length;
  }
  if (a.length <= 32) {
    return myers_32(a, b);
  }
  return myers_x(a, b);
};

// /:https://framerusercontent.com/modules/MWsEnYfRnoOQq31DN4ql/C71JVnvNwV2CrPvApXBB/utils.js
var localStorageDebugFlag = typeof window !== "undefined" && window.localStorage.getItem("__framerDebugSearch") === "true";
var groupsRegex = /[A-Z]{2,}|[A-Z][a-z]+|[a-z]+|[A-Z]\d*|\d+/gu;
function capitalizeFirstLetter(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function titleCase(value) {
  const groups = value.match(groupsRegex) || [];
  return groups.map(capitalizeFirstLetter).join(" ");
}
function clampText(text, maxLength) {
  const textLength = text.length;
  if (textLength <= maxLength) {
    return text;
  }
  const slicedText = text.slice(0, maxLength);
  if (textLength > maxLength) {
    return slicedText + "\u2026";
  }
  return slicedText;
}
function isEmptyObject(object) {
  return Object.keys(object).length === 0;
}
function createLogger(showOutput) {
  function log2(...data) {
    console.log(Date.now(), ...data);
  }
  function time2(label) {
    console.time(label);
  }
  function timeEnd2(label) {
    console.timeEnd(label);
  }
  function noop() {
  }
  if (!showOutput) {
    return { log: noop, time: noop, timeEnd: noop };
  }
  return { log: log2, time: time2, timeEnd: timeEnd2 };
}
var DEFAULT_FONT_FAMILY = `"Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
function getFontFamily(theme) {
  var _theme_inputFont, _theme_titleFont, _theme_subtitleFont;
  if ((_theme_inputFont = theme.inputFont) === null || _theme_inputFont === void 0 ? void 0 : _theme_inputFont.fontFamily) return theme.inputFont.fontFamily;
  if ((_theme_titleFont = theme.titleFont) === null || _theme_titleFont === void 0 ? void 0 : _theme_titleFont.fontFamily) return theme.titleFont.fontFamily;
  if ((_theme_subtitleFont = theme.subtitleFont) === null || _theme_subtitleFont === void 0 ? void 0 : _theme_subtitleFont.fontFamily) return theme.subtitleFont.fontFamily;
  return DEFAULT_FONT_FAMILY;
}
function animationKeyFromLayout(layout) {
  return `${layout}Animation`;
}
var safeDocument = typeof document !== "undefined" ? document : null;
var safeWindow = typeof window !== "undefined" ? window : null;
var metaTagSelector = 'meta[name="framer-search-index"]';
function getMetaTagContent() {
  const metaTag = safeDocument === null || safeDocument === void 0 ? void 0 : safeDocument.querySelector(metaTagSelector);
  if (!metaTag) return void 0;
  const metaTagContent = metaTag.getAttribute("content");
  return metaTagContent;
}
var checkIfOverLimit = () => {
  return getMetaTagContent() === "limit-reached";
};
function stripLocaleSlugFromPath(url, localeSlug) {
  if (!localeSlug) return url;
  const localeSlugWithSlash = `/${localeSlug}`;
  if (url.startsWith(localeSlugWithSlash)) {
    return url.slice(localeSlugWithSlash.length);
  }
}

// /:https://framerusercontent.com/modules/MyBp84Z0p9nUcMimVMnY/y5F4AGWJ6syeuoB7ebKM/useSearch.js
var { log, time, timeEnd } = createLogger(localStorageDebugFlag);
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch (_error) {
    return false;
  }
}
function splitWords(text) {
  try {
    return text.split(RegExp("[\\s.,;!?\\p{P}\\p{Z}]+(?<!\\p{L}&)(?!&\\p{L})", "u"));
  } catch {
    log("Falling back to regex without lookbehind");
    return text.split(RegExp("[\\s.,;!?\\p{P}\\p{Z}]+", "u"));
  }
}
function getUniqueWords(str) {
  const words = splitWords(str).filter((word) => word.trim() && word.length > 0);
  return new Set(words);
}
function getNormalizedString(text) {
  if (Array.isArray(text)) {
    return text.map(getNormalizedString);
  }
  return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
}
function getNormalizedItem(item) {
  const normalizedItem = {};
  for (const [key, value] of Object.entries(item)) {
    if (typeof value === "string") {
      normalizedItem[key] = getNormalizedString(value);
      continue;
    }
    if (Array.isArray(value)) {
      normalizedItem[key] = getNormalizedString(value);
      continue;
    }
    normalizedItem[key] = value;
  }
  return normalizedItem;
}
function getMatchRange(currentRange, start, end) {
  const result = { ...currentRange };
  if (start < result.start) {
    result.start = start;
  }
  if (end > result.end) {
    result.end = end;
  }
  return result;
}
function getScoreForSearchIndexItem(item, query, words, fullQuery) {
  let score = 0;
  const match = { title: { start: Infinity, end: 0 }, description: { start: Infinity, end: 0 } };
  const urlWords = getUniqueWords(item.url);
  if (urlWords.has(query)) {
    score += 10;
  }
  if (words.size === 1 && urlWords.size === 1 && urlWords.values().next().value === query) {
    score += score * 5;
  }
  if (score > 0) {
    const splitLength = item.url.split("/").length;
    score += clamp(10 - splitLength, 0, splitLength);
  }
  const titleWords = getUniqueWords(item.title);
  if (titleWords.has(query)) {
    score += 10;
  }
  const titleIndex = item.title.indexOf(query);
  if (titleIndex !== -1) {
    score += 10;
    match.title = getMatchRange(match.title, titleIndex, titleIndex + query.length);
  }
  if (distance(item.title, fullQuery) <= 2) {
    score += score * 10;
  }
  for (const titleWord of titleWords) {
    const distanceScore = distance(query, titleWord);
    if (distanceScore <= 2) {
      score += 10;
    }
  }
  const headings = [...item.h1, ...item.h2, ...item.h3, ...item.h4, ...item.h5, ...item.h6];
  for (const heading of headings) {
    const headingWords = getUniqueWords(heading);
    if (distance(heading, fullQuery) <= 2) {
      score += score * 10;
    }
    if (heading.startsWith(query)) {
      score += 10;
    }
    if (headingWords.has(query)) {
      score += 10;
    }
    if (heading.includes(query)) {
      score += 1;
    }
    for (const headingWord of headingWords) {
      const distanceScore = distance(query, headingWord);
      if (distanceScore <= 2) {
        score += 1;
      }
    }
  }
  const descriptionIndex = item.description.indexOf(query);
  if (descriptionIndex !== -1) {
    score += 10;
    match.description = getMatchRange(match.description, descriptionIndex, descriptionIndex + query.length);
  }
  for (const p of item.p) {
    if (p.includes(query)) {
      score += 0.5;
    }
  }
  for (const codeblock of item.codeblock) {
    if (distance(codeblock, fullQuery) <= 2) {
      score *= 10;
    }
    if (codeblock.includes(fullQuery)) {
      score += 10;
    }
    if (codeblock.includes(query)) {
      score += 0.5;
    }
  }
  return { score, match };
}
function getSearchIndexItemScore(item, query) {
  const normalizedItem = getNormalizedItem(item);
  const normalizedQuery = getNormalizedString(query);
  const queryWords = getUniqueWords(normalizedQuery);
  let total = 0;
  for (const queryWord of queryWords) {
    const { score } = getScoreForSearchIndexItem(normalizedItem, queryWord, queryWords, normalizedQuery);
    total += score;
  }
  return total;
}
function useRawSearch(index, query, settings) {
  const results = useMemo(() => {
    if (!query || !index) {
      return [];
    }
    const path = safeWindow === null || safeWindow === void 0 ? void 0 : safeWindow.location.pathname;
    time("query");
    const results2 = Object.values(index).map((item) => {
      const score = getSearchIndexItemScore(item, query);
      const heading = item.h1.length && item.h1[0];
      const title = (settings === null || settings === void 0 ? void 0 : settings.titleType) === SearchResultTitleType.Title ? item.title : heading ? heading : item.title;
      const result = { url: item.url, title, description: item.description, body: [...item.p, item.codeblock].join(" "), score };
      return result;
    }).filter((item) => item.score > settings.minimumScore || 0).filter((item) => {
      if (!path) return true;
      return item.url !== path;
    }).sort((itemA, itemB) => itemB.score - itemA.score);
    timeEnd("query");
    return results2;
  }, [index, query]);
  return results;
}
function getIndexedScopedToUrl(index, rawUrlScope, localeSlug) {
  const scopedIndex = {};
  const baseScopeUrlHasVariable = rawUrlScope.includes(":");
  const urlUpToPathVariable = rawUrlScope.split(":")[0];
  const urlScope = urlUpToPathVariable.length > 1 ? urlUpToPathVariable : "";
  for (const url in index) {
    const strippedURL = stripLocaleSlugFromPath(url, localeSlug);
    if (!strippedURL.startsWith(urlScope)) {
      continue;
    }
    if (baseScopeUrlHasVariable && url.length <= urlScope.length) {
      continue;
    }
    scopedIndex[url] = index[url];
  }
  return scopedIndex;
}
function useSearch(query, settings) {
  const [searchIndex, _setSearchIndex] = useState({});
  const [status, setStatus] = useState("loading");
  const results = useRawSearch(searchIndex, query, settings);
  const { activeLocale } = useLocaleInfo();
  const localeId = activeLocale === null || activeLocale === void 0 ? void 0 : activeLocale.id;
  function setSearchIndex(index, options = { ignoreScope: false }) {
    let scopedIndex = index;
    if (settings.urlScope && !options.ignoreScope) {
      scopedIndex = getIndexedScopedToUrl(index, settings.urlScope, activeLocale === null || activeLocale === void 0 ? void 0 : activeLocale.slug);
      log("Using URL scope", settings.urlScope);
    }
    _setSearchIndex(scopedIndex);
  }
  useEffect(() => {
    async function loadSearchIndex() {
      setStatus("loading");
      const metaTag = safeDocument === null || safeDocument === void 0 ? void 0 : safeDocument.querySelector('meta[name="framer-search-index"]');
      if (!metaTag) {
        setStatus("no-meta-tag-found");
        setSearchIndex(fakeResults, { ignoreScope: true });
        log("No meta tag found");
        return;
      }
      const cachedIndex = await getCachedIndex(localeId);
      const metaTagContent = metaTag.getAttribute("content");
      const isOverLimit = metaTagContent === "limit-reached";
      if (isOverLimit) {
        log("Page limit for plan exceeded");
      }
      if (cachedIndex && !isOverLimit) {
        setSearchIndex(cachedIndex);
        setStatus("loading-with-cache");
        log("Using cached index");
      }
      if (!metaTagContent || !isValidUrl(metaTagContent)) {
        log("Meta tag exists but URL is not valid yet");
        if (!cachedIndex) {
          setStatus("pending-index-generation");
          log("No cache to use, page reload required to check for meta tag");
        } else {
          log("Continue using cache");
        }
        return;
      }
      const searchIndexURL = getSearchIndexURL(metaTagContent, localeId);
      const response = await fetch(searchIndexURL);
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      const downloadedIndex = await response.json();
      setSearchIndex(downloadedIndex);
      setCachedIndex(localeId, downloadedIndex);
      setStatus("success");
      log("Using downloaded index");
    }
    loadSearchIndex().catch((error) => {
      setStatus("error");
      log("Failed to load search index", error);
    });
  }, [localeId]);
  log({ status, results });
  return { results, status };
}
function getSearchIndexURL(baseURL, localeId) {
  if (isDefaultLocaleId(localeId)) return baseURL;
  return baseURL.replace(".json", `-${localeId}.json`);
}

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import React, { useEffect as useEffect2, useState as useState2, useMemo as useMemo2, forwardRef, useRef as useRef2, useDeferredValue, useLayoutEffect, useCallback as useCallback2, useImperativeHandle } from "react";

// /:https://framerusercontent.com/modules/PJVBcBLmDteTEAZh3J9Z/keXJyjyE9VnzUcDMayjg/browser.js
var __unframerNavigator = typeof window !== "undefined" ? navigator : void 0;
var Browser;
(function(Browser2) {
  var isTouch = Browser2.isTouch = () => "ontouchstart" in window || __unframerNavigator.maxTouchPoints > 0;
  var isChrome = Browser2.isChrome = () => __unframerNavigator.userAgent.toLowerCase().includes("chrome/");
  var isWebKit = Browser2.isWebKit = () => __unframerNavigator.userAgent.toLowerCase().includes("applewebkit/");
  var isSafari = Browser2.isSafari = () => isWebKit() && !isChrome();
  var isSafariDesktop = Browser2.isSafariDesktop = () => isSafari() && !isTouch();
  var isWindows = Browser2.isWindows = () => /Win/.test(__unframerNavigator.platform);
  var isMacOS = Browser2.isMacOS = () => /Mac/.test(__unframerNavigator.platform);
})(Browser || (Browser = {}));

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import { motion as motion2, clamp as clamp2, useAnimate } from "unframer";

// /:https://framerusercontent.com/modules/Gzef0nFihI9m9vZG45th/lIUxbZcreiDm2GzUkt3y/useCallbackOnMouseMove.js
import { useRef, useCallback } from "react";
var useCallbackOnMouseMove = (callback, mousePositionRef) => {
  const prevPositionRef = useRef(null);
  return useCallback((event) => {
    if (!Browser.isSafari()) return callback(event);
    const ref = mousePositionRef ? mousePositionRef : prevPositionRef;
    const { clientX, clientY } = event;
    const prevCursorPosition = ref.current;
    ref.current = { x: clientX, y: clientY };
    if (!prevCursorPosition) {
      return;
    }
    if (prevCursorPosition.x !== clientX || prevCursorPosition.y !== clientY) {
      return callback(event);
    }
  }, [mousePositionRef, callback]);
};

// /:https://framerusercontent.com/modules/eAnjm75CdfYT1Zz4BIaz/7KDSfnnyD1T3Ap75L4m8/scrollIntoView.js
function scrollIntoView(targetElement, scrollElement, { offsetTop, offsetBottom }) {
  const targetElementBounds = targetElement.getBoundingClientRect();
  const scrollElementBounds = scrollElement.getBoundingClientRect();
  if (targetElementBounds.top < scrollElementBounds.top) {
    const difference = scrollElementBounds.top - targetElementBounds.top;
    scrollElement.scrollTop = scrollElement.scrollTop - difference - offsetTop;
  } else if (targetElementBounds.bottom > scrollElementBounds.bottom) {
    const topAligned = scrollElementBounds.top - targetElementBounds.top;
    const minOffset = scrollElement.scrollTop - topAligned - offsetTop;
    const bottomAligned = targetElementBounds.bottom - scrollElementBounds.bottom;
    const offset = scrollElement.scrollTop + bottomAligned + offsetBottom;
    scrollElement.scrollTop = Math.min(minOffset, offset);
  }
}

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import {
  useLocaleInfo as useLocaleInfo2,
  useRouter,
  inferInitialRouteFromPath
} from "unframer";
var MAX_DESCRIPTION_LENGTH = 120;
var MODAL_MAX_HEIGHT = 496;
var VERTICAL_SPACING_MULTIPLIER = 0.6;
function ClearButton({ theme, type, onClick, text }) {
  const shouldDisplayIcon = type === "icon";
  const iconOrText = shouldDisplayIcon ? /* @__PURE__ */ _jsx2(ClearIcon, { style: { color: theme.inputIconColor, width: theme.inputIconSize, height: theme.inputIconSize } }) : text;
  return /* @__PURE__ */ _jsx2("div", { style: { flexShrink: 0, fontSize: theme && theme.titleFont && theme.titleFont.fontSize ? theme.titleFont.fontSize : 15 }, children: /* @__PURE__ */ _jsx2("button", { className: "__framer-search-clear-button", onClick, style: { fontFamily: "inherit", border: "none", background: "none", cursor: "pointer", display: "flex", textTransform: "uppercase", color: theme.inputIconColor, fontSize: "0.75em", padding: 0 }, children: iconOrText }) });
}
function Divider({ theme, type }) {
  const styles = { background: theme.foregroundColor, height: 1, flexShrink: 0, opacity: 0.05 };
  if (type === "contained" && theme) {
    styles.marginLeft = theme.horizontalSpacing;
    styles.marginRight = theme.horizontalSpacing;
  }
  return /* @__PURE__ */ _jsx2("div", { style: styles });
}
var Input = /* @__PURE__ */ forwardRef(function Input2(props, ref) {
  const { value = "", status, autofocus, theme, placeholder, iconType, clearButtonType, onChange } = props;
  const [inputValue, setInputValue] = useState2(value);
  const [isFocused, setIsFocused] = useState2(false);
  const inputRef = useRef2();
  useImperativeHandle(ref, () => inputRef.current);
  React.useLayoutEffect(() => {
    return () => {
      const inputElement = inputRef.current;
      if (!inputElement || inputElement !== document.activeElement) return;
      inputElement.blur();
    };
  }, []);
  const handleInputClick = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  const handleClearClick = () => {
    setInputValue("");
  };
  useEffect2(() => {
    onChange(inputValue);
  }, [inputValue]);
  const hasInputText = inputValue.length > 0;
  const showClearButton = inputValue.length > 0 && clearButtonType && clearButtonType !== "none";
  const verticalSpacing = Math.floor(theme ? theme.horizontalSpacing * VERTICAL_SPACING_MULTIPLIER : 0);
  const searchIcon = iconType === "custom" && theme.inputIconImage ? /* @__PURE__ */ _jsx2("img", { alt: "icon alongside the Site Search input", src: theme.inputIconImage.src, width: theme.inputIconSize, height: theme.inputIconSize }) : /* @__PURE__ */ _jsx2(SearchIcon, { color: theme.inputIconColor, width: theme.inputIconSize, height: theme.inputIconSize });
  return /* @__PURE__ */ _jsxs2("div", { role: "search", style: { ...inputContainerStyle, fontFamily: getFontFamily(theme), paddingLeft: theme && theme.horizontalSpacing, paddingRight: theme && theme.horizontalSpacing, gap: 12, paddingTop: verticalSpacing, paddingBottom: verticalSpacing, touchAction: "none" }, onClick: handleInputClick, children: [/* @__PURE__ */ _jsx2("div", { style: { flexShrink: 0, display: "flex" }, children: status === "loading" && inputValue ? /* @__PURE__ */ _jsx2(SpinnerIcon, { color: theme.inputIconColor, backgroundColor: theme.backgroundColor, style: { height: theme && theme.inputIconSize, width: theme && theme.inputIconSize } }) : searchIcon }), /* @__PURE__ */ _jsx2("input", { ref: inputRef, spellCheck: false, autoFocus: autofocus, style: {
    ...inputStyle,
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    color: theme.foregroundColor,
    lineHeight: "2em",
    verticalAlign: "baseline",
    ...theme.titleFont,
    ...theme.inputFont,
    fontSize: theme.inputFontSize,
    // @ts-ignore
    "--framer-search-placeholder-color": theme.placeholderColor
  }, onFocus: () => {
    const scrollOffset = document.documentElement.scrollTop;
    document.documentElement.scrollTop = scrollOffset;
  }, placeholder, value: inputValue, onChange: () => setInputValue(inputRef.current.value) }), showClearButton && /* @__PURE__ */ _jsx2(ClearButton, { theme, type: props.clearButtonType, text: props.clearButtonText, onClick: handleClearClick })] });
});
var inputContainerStyle = { display: "inline-flex", alignItems: "center", flexShrink: 0 };
var inputStyle = { outline: "none", border: "none", background: "transparent", fontWeight: 500, height: "2em", padding: 0, width: "100%" };
var ResultRow = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function ResultRow2(props, ref) {
  const { index, result, prevMousePositionRef, type = "contained", subtitleType = "path", selected = false, theme, localeSlug, style, onMouseMove, onPointerDown, onNavigateTo } = props;
  const { url, title, score } = result;
  const urlPath = useMemo2(() => {
    return stripLocaleSlugFromPath(url, localeSlug);
  }, [url, localeSlug]);
  const handleMouseMove = useCallbackOnMouseMove((event) => onMouseMove(event, index), prevMousePositionRef);
  const isContained = type === "contained";
  const borderRadius = isContained ? clamp2(0, Infinity, theme.borderRadius - theme.spacing) : 0;
  const subtitleText = subtitleType === "path" ? urlPath : clampText(result.description, MAX_DESCRIPTION_LENGTH);
  const handleClick = (event) => {
    event.preventDefault();
    onNavigateTo(result.url);
  };
  const focusTrap = (event) => {
    event.preventDefault();
  };
  return /* @__PURE__ */ _jsx2("a", { ref, style: { textDecoration: "none" }, href: result.url, onClick: handleClick, onMouseMove: handleMouseMove, onMouseDown: focusTrap, onPointerDown: (event) => onPointerDown(event, index), children: /* @__PURE__ */ _jsxs2("li", { style: { ...resultContainer, ...style, paddingTop: isContained ? 12 : 16, paddingBottom: isContained ? 12 : 16, color: theme.foregroundColor, position: "relative", paddingLeft: theme && theme.horizontalSpacing, paddingRight: theme && theme.horizontalSpacing }, children: [/* @__PURE__ */ _jsx2("div", { style: { backgroundColor: theme.foregroundColor, position: "absolute", opacity: selected ? 0.06 : 0, borderRadius, left: theme && isContained ? theme.spacing : 0, right: theme && isContained ? theme.spacing : 0, top: 0, bottom: 0 } }), /* @__PURE__ */ _jsxs2("div", { style: { display: "flex", flexDirection: "column", overflow: "hidden", gap: 4 }, children: [/* @__PURE__ */ _jsx2("h3", { style: { ...resultTitle, ...theme.titleFont, lineHeight: "1.4em" }, children: title }), /* @__PURE__ */ _jsxs2("p", { style: { margin: 0, color: theme.subtitleColor, ...theme.subtitleFont, whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis", lineHeight: "1.4em" }, children: [localStorageDebugFlag ? score : "", " ", subtitleText] })] })] }, result.url) });
}));
function QuickMenuSpacer({ onClick }) {
  return /* @__PURE__ */ _jsx2("div", { style: { width: "100%", flexBasis: "20vh" }, onClick });
}
var layoutContainerStyle = { display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "flex-start", gap: 15, overflow: "visible" };
function LayoutContainer({ layoutType, theme, onKeyDown, onDismiss, children, modalOptions }) {
  const layoutStyles = getLayoutBaseStyles(layoutType, theme);
  const style = { ...layoutContainerStyle, ...layoutStyles, willChange: "transform", marginTop: layoutType === "FixedTop" ? theme.offsetTop : 0, height: layoutType === "Sidebar" ? "100%" : "auto", maxHeight: layoutType === "QuickMenu" ? "100%" : "none", justifyContent: layoutType === "Sidebar" ? "flex-end" : "flex-start", flexDirection: layoutType === "Sidebar" ? "column-reverse" : "column" };
  const innerStyle = { ...layoutContainerStyle, ...layoutStyles, height: layoutType === "Sidebar" ? "100%" : "auto", maxHeight: layoutType === "QuickMenu" ? "100%" : "none", gap: layoutType === "Sidebar" ? 0 : theme.gapBetweenStatusAndSearch, backgroundColor: layoutType === "Sidebar" ? theme.backgroundColor : "transparent", justifyContent: layoutType === "Sidebar" ? "flex-end" : "flex-start", flexDirection: layoutType === "Sidebar" ? "column-reverse" : "column", originX: 0.5, originY: 0.5 };
  function getContainerAnimation() {
    switch (layoutType) {
      case "FixedTop": {
        const key = animationKeyFromLayout("FixedTop");
        const prop = modalOptions ? modalOptions[key] : void 0;
        if (prop) {
          return prop;
        } else {
          return { y: -10, opacity: 0.2, transition: { duration: Browser.isTouch() ? 0 : 0.15 } };
        }
        break;
      }
      case "QuickMenu": {
        const key = animationKeyFromLayout("QuickMenu");
        const prop = modalOptions ? modalOptions[key] : void 0;
        if (prop) {
          return prop;
        } else {
          return { scale: 0.95, opacity: 0, y: 0, x: 0, rotate: 0, transition: { type: "spring", stiffness: 600, damping: 40 } };
        }
        break;
      }
      case "Sidebar": {
        const key = animationKeyFromLayout("Sidebar");
        const prop = modalOptions ? modalOptions[key] : void 0;
        if (prop) {
          return prop;
        } else {
          return { x: -10, opacity: 0, transition: { duration: 0.15 } };
        }
        break;
      }
    }
  }
  const containerAnimation = getContainerAnimation();
  return /* @__PURE__ */ _jsxs2("div", { style, onKeyDown, onClick: (event) => event.stopPropagation(), children: [layoutType === "QuickMenu" && /* @__PURE__ */ _jsx2(QuickMenuSpacer, { onClick: onDismiss }), /* @__PURE__ */ _jsx2(motion2.div, { initial: containerAnimation, animate: { opacity: 1, scale: 1, x: 0, y: 0, rotate: 0 }, transition: containerAnimation ? containerAnimation.transition : void 0, exit: { opacity: 0, transition: { duration: 0 } }, style: innerStyle, children })] });
}
function ModalContainer({ layoutType, theme, children, heightIsStatic, heightTransition, heightDeps }) {
  const style = {
    // This `willChange` is required to avoid weird rendering issues where
    // parts of the search window won't redraw, which we observed in Safari 16.4.
    willChange: "transform",
    backgroundColor: theme.backgroundColor,
    color: theme.foregroundColor,
    borderRadius: layoutType === "QuickMenu" ? theme.borderRadius : 0,
    width: "100%",
    display: "flex",
    flexDirection: "column",
    overflow: "hidden",
    boxShadow: layoutType !== "Sidebar" ? theme.shadow : void 0,
    maxHeight: layoutType === "QuickMenu" ? `min(${MODAL_MAX_HEIGHT}px, calc(100vh - 30px))` : void 0
  };
  const [scope, animate] = useAnimate();
  useLayoutEffect(() => {
    if (layoutType !== "QuickMenu" || heightIsStatic) return;
    const prevHeight = scope.current.offsetHeight;
    scope.current.style.height = "auto";
    const height = scope.current.offsetHeight;
    scope.current.style.height = prevHeight + "px";
    animate(scope.current, { height: [prevHeight, height] }, heightTransition);
  }, heightDeps);
  return /* @__PURE__ */ _jsx2("div", { ref: scope, role: "dialog", className: layoutType === "FixedTop" ? "__framer-max-height-80dvh" : void 0, style, children });
}
var ScrollView = /* @__PURE__ */ React.forwardRef(function ScrollView2({ theme, children }, ref) {
  const isTouch = Browser.isTouch();
  const [canScroll, setCanScroll] = React.useState(true);
  React.useEffect(() => {
    if (!isTouch) return;
    const element = ref.current;
    if (!element) return;
    setCanScroll(element.scrollHeight > element.clientHeight);
  });
  return /* @__PURE__ */ _jsx2("div", { ref, style: {
    width: `calc(100% + ${theme.scrollBarWidth}px)`,
    overflowY: "scroll",
    overflowX: "hidden",
    overscrollBehavior: "contain",
    touchAction: canScroll ? void 0 : "none",
    // Make the list appear slightly under the divider
    // so that the divider is still visible when the first
    // item is selected.
    marginTop: -1
  }, children });
});
var statusStyle = { backgroundColor: "#B5B5B5", color: "#FFF", boxShadow: "0px 20px 40px 0px rgba(0, 0, 0, 0.25)", fontFamily: "inherit", textAlign: "center", fontSize: 13, padding: "8px 0" };
function StatusMessage({ status, layoutType, theme }) {
  const verticalSpacing = Math.floor(theme ? theme.horizontalSpacing * VERTICAL_SPACING_MULTIPLIER : 0);
  const style = { ...statusStyle, userSelect: "none", fontFamily: getFontFamily(theme), paddingLeft: theme && theme.horizontalSpacing, paddingRight: theme && theme.horizontalSpacing, fontWeight: 500, lineHeight: `calc(${theme.inputFontSize} * 2)`, paddingTop: verticalSpacing, paddingBottom: verticalSpacing, ...theme.titleFont, zIndex: theme.zIndex + 1, maxWidth: layoutType === "FixedTop" ? "none" : theme.width, width: layoutType === "FixedTop" ? `calc(100% - ${verticalSpacing * 2}px` : "100%", boxShadow: layoutType !== "Sidebar" && statusStyle.boxShadow, borderRadius: layoutType !== "Sidebar" && theme.borderRadius };
  const previewInfoText = layoutType === "FixedTop" ? "Preview Mode" : "Preview Mode. Publish your Site to Search.";
  if (status === "no-meta-tag-found") {
    return /* @__PURE__ */ _jsx2("div", { style, children: previewInfoText });
  }
  if (status === "pending-index-generation") {
    return /* @__PURE__ */ _jsx2("div", { style, children: "Site is being indexed" });
  }
  return null;
}
var resultTitle = { textOverflow: "ellipsis", maxWidth: "100%", overflow: "hidden", fontWeight: 500, whiteSpace: "nowrap", flex: 1, margin: 0 };
var resultContainer = { padding: "16px 20px", listStyle: "none", fontWeight: 500 };
var sidebarStyles = { left: 0, width: 500 };
var fixedTopStyles = { top: 0, width: "100%" };
var quickMenuStyles = { width: 500 };
function getLayoutBaseStyles(layoutOption, theme) {
  switch (layoutOption) {
    case "Sidebar":
      return { ...sidebarStyles, width: theme.width };
    case "FixedTop":
      return fixedTopStyles;
    case "QuickMenu":
      return { ...quickMenuStyles, width: theme.width };
  }
}
var SearchInputClearButtonType;
(function(SearchInputClearButtonType2) {
  SearchInputClearButtonType2["Icon"] = "icon";
  SearchInputClearButtonType2["Text"] = "text";
  SearchInputClearButtonType2["None"] = "none";
})(SearchInputClearButtonType || (SearchInputClearButtonType = {}));
var SearchInputDividerType;
(function(SearchInputDividerType2) {
  SearchInputDividerType2["None"] = "none";
  SearchInputDividerType2["FullWidth"] = "fullWidth";
  SearchInputDividerType2["Contained"] = "contained";
})(SearchInputDividerType || (SearchInputDividerType = {}));
var SearchResultTitleType;
(function(SearchResultTitleType2) {
  SearchResultTitleType2["H1"] = "h1";
  SearchResultTitleType2["Title"] = "title";
})(SearchResultTitleType || (SearchResultTitleType = {}));
var SearchResultSubtitleType;
(function(SearchResultSubtitleType2) {
  SearchResultSubtitleType2["Description"] = "description";
  SearchResultSubtitleType2["Path"] = "path";
})(SearchResultSubtitleType || (SearchResultSubtitleType = {}));
var SearchResultItemType;
(function(SearchResultItemType2) {
  SearchResultItemType2["FullWidth"] = "fullWidth";
  SearchResultItemType2["Contained"] = "contained";
})(SearchResultItemType || (SearchResultItemType = {}));
var SearchLayoutType;
(function(SearchLayoutType2) {
  SearchLayoutType2["Sidebar"] = "Sidebar";
  SearchLayoutType2["FixedTop"] = "FixedTop";
  SearchLayoutType2["QuickMenu"] = "QuickMenu";
})(SearchLayoutType || (SearchLayoutType = {}));
var SearchEntryType;
(function(SearchEntryType2) {
  SearchEntryType2["Icon"] = "icon";
  SearchEntryType2["Text"] = "text";
})(SearchEntryType || (SearchEntryType = {}));
var SearchIconType;
(function(SearchIconType2) {
  SearchIconType2["Default"] = "default";
  SearchIconType2["Custom"] = "custom";
})(SearchIconType || (SearchIconType = {}));
function SearchModal(props) {
  const { layoutType, theme, urlScope, inputOptions, backdropOptions, modalOptions, resultOptions, onDismiss } = props;
  const { activeLocale } = useLocaleInfo2();
  const localeId = activeLocale === null || activeLocale === void 0 ? void 0 : activeLocale.id;
  const localeSlug = activeLocale === null || activeLocale === void 0 ? void 0 : activeLocale.slug;
  const input = useRef2();
  const selectedResultRow = useRef2();
  const scrollView = useRef2();
  const [selected, setSelected] = useState2({ index: 0, scroll: true });
  const prevMousePositionRef = useRef2(null);
  const [isKeyboardNavigationDisabled, setIsKeyboardNavigationDisabled] = useState2(Browser.isTouch);
  const [query, setQuery] = useState2("");
  const deferredQuery = useDeferredValue(query);
  const { results, status } = useSearch(deferredQuery, { minimumScore: 0, urlScope, titleType: resultOptions.titleType });
  const selectedResult = results[selected.index];
  const verticalSpacing = Math.floor(theme ? theme.horizontalSpacing * VERTICAL_SPACING_MULTIPLIER : 0);
  useEffect2(() => {
    setSelected({ index: 0, scroll: true });
  }, [deferredQuery]);
  const handleResultRowPointerDown = useCallback2((event, index) => {
    if (event.pointerType !== "touch") return;
    setIsKeyboardNavigationDisabled(true);
    setSelected({ index, scroll: false });
  }, []);
  const handleResultRowMouseMove = useCallback2((event, index) => {
    setSelected((previousSelected) => {
      if (previousSelected.index === index) {
        return previousSelected;
      }
      return { index, scroll: false };
    });
  }, []);
  const router = useRouter();
  const navigateTo = useCallback2(async (url) => {
    if (status === "no-meta-tag-found") {
      return;
    }
    try {
      var _router_getRoute, _route_page_preload, _route_page, _router_navigate;
      const { routeId, pathVariables } = inferInitialRouteFromPath(router.routes, url);
      const route = (_router_getRoute = router.getRoute) === null || _router_getRoute === void 0 ? void 0 : _router_getRoute.call(router, routeId);
      onDismiss();
      await (route === null || route === void 0 ? void 0 : (_route_page = route.page) === null || _route_page === void 0 ? void 0 : (_route_page_preload = _route_page.preload) === null || _route_page_preload === void 0 ? void 0 : _route_page_preload.call(_route_page));
      (_router_navigate = router.navigate) === null || _router_navigate === void 0 ? void 0 : _router_navigate.call(router, routeId, null, pathVariables, false);
    } catch (error) {
      window.location.href = url;
    }
  }, [status]);
  const handleKeyDown = (event) => {
    const maxIndex = results.length - 1;
    switch (event.code) {
      case "ArrowUp":
        event.preventDefault();
        if (isKeyboardNavigationDisabled) {
          setIsKeyboardNavigationDisabled(false);
          break;
        }
        setSelected((previousSelected) => ({ index: clamp2(0, maxIndex, previousSelected.index - 1), scroll: true }));
        break;
      case "ArrowDown":
        event.preventDefault();
        if (isKeyboardNavigationDisabled) {
          setIsKeyboardNavigationDisabled(false);
          break;
        }
        setSelected((previousSelected) => ({ index: clamp2(0, maxIndex, previousSelected.index + 1), scroll: true }));
        break;
      case "Escape":
        break;
      case "Enter":
        if (selectedResult) {
          navigateTo(selectedResult.url);
        }
        break;
      default:
        event.stopPropagation();
    }
  };
  const showNoResults = results.length === 0 && deferredQuery.length > 1 && status !== "loading";
  const showDivider = Boolean((deferredQuery.length > 0 && results.length > 0 || showNoResults) && status !== "loading" && props.inputOptions && props.inputOptions.dividerType !== "none");
  const isItemContained = Boolean(props.resultOptions && props.resultOptions.itemType === "contained");
  const spacing = isItemContained ? theme.spacing : 10;
  const listPaddingTop = showDivider && isItemContained ? spacing + theme.gapBetweenResults * 2 : 0;
  useEffect2(() => {
    if (!selected.scroll) return;
    const element = selectedResultRow.current;
    if (!element) return;
    scrollIntoView(element, scrollView.current, { offsetTop: showDivider && isItemContained ? listPaddingTop : 0, offsetBottom: isItemContained ? spacing : 0 });
  }, [selected]);
  return /* @__PURE__ */ _jsxs2(LayoutContainer, { layoutType, modalOptions, theme, onKeyDown: handleKeyDown, onDismiss, children: [/* @__PURE__ */ _jsxs2(ModalContainer, { layoutType, theme, heightIsStatic: modalOptions.heightIsStatic, heightTransition: modalOptions.heightTransition, heightDeps: [results.length, showNoResults], children: [/* @__PURE__ */ _jsx2(Input, { autofocus: true, ref: input, onChange: setQuery, value: query, theme, status, iconType: inputOptions.iconOptions.iconType, placeholder: inputOptions.placeholderOptions.placeholderText, clearButtonType: inputOptions ? inputOptions.clearButtonType : void 0, clearButtonText: inputOptions.clearButtonText }), showDivider && /* @__PURE__ */ _jsx2(Divider, { theme, type: inputOptions.dividerType }), /* @__PURE__ */ _jsx2(ScrollView, { ref: scrollView, theme, children: /* @__PURE__ */ _jsxs2("ul", { "aria-live": "polite", style: { display: "flex", flexDirection: "column", width: `calc(100% - ${theme.scrollBarWidth}px)`, padding: 0, paddingTop: listPaddingTop, paddingBottom: results.length && isItemContained ? spacing : 0, gap: theme.gapBetweenResults, margin: 0 }, children: [results.map((result, index) => {
    const isSelected = index === selected.index;
    return /* @__PURE__ */ _jsx2(ResultRow, { ref: isSelected ? selectedResultRow : null, index, result, prevMousePositionRef, selected: !isKeyboardNavigationDisabled && isSelected, type: props.resultOptions.itemType, subtitleType: props.resultOptions.subtitleOptions.subtitleType, theme, localeSlug, onMouseMove: handleResultRowMouseMove, onPointerDown: handleResultRowPointerDown, onNavigateTo: navigateTo }, result.url);
  }), showNoResults && /* @__PURE__ */ _jsx2("li", { style: { paddingTop: verticalSpacing - listPaddingTop, paddingBottom: verticalSpacing, lineHeight: "2em", paddingLeft: theme && theme.horizontalSpacing, paddingRight: theme && theme.horizontalSpacing, height: "Sidebar" ? "100%" : "auto" }, children: /* @__PURE__ */ _jsx2("h3", { style: { ...resultTitle, textAlign: "center", lineHeight: `calc(${theme.inputFontSize} * 2)`, color: theme.subtitleColor, ...theme.titleFont }, children: "No results" }) })] }) })] }), /* @__PURE__ */ _jsx2(StatusMessage, { status, layoutType, theme })] });
}

// /:https://framerusercontent.com/modules/hqEf5wXaAewP8VPuaZ98/5A0QGVeEr2cwheQpIuEG/useViewportSizeState.js
import { useEffect as useEffect3, useState as useState3 } from "react";
function getViewportSize() {
  if (typeof window === "undefined") {
    return { width: 0, height: 0 };
  }
  return { width: window.innerWidth, height: window.innerHeight };
}
function useViewportSizeState(getState) {
  const [state, setState] = useState3(() => getState(getViewportSize()));
  useEffect3(() => {
    const handleWindowResize = () => setState(getState(getViewportSize()));
    window.addEventListener("resize", handleWindowResize);
    return () => {
      window.removeEventListener("resize", handleWindowResize);
    };
  }, []);
  return state;
}

// /:https://framerusercontent.com/modules/6wAE2eMb2Tl3zrU7u4UL/HPzg2Uk7mwtBmDzvGbWF/Search.js
var EntryPointOptions;
(function(EntryPointOptions2) {
  EntryPointOptions2["icon"] = "Icon";
  EntryPointOptions2["input"] = "Input";
})(EntryPointOptions || (EntryPointOptions = {}));
function buildShadow(shadowProperty, fallback = "none") {
  if (!shadowProperty) return fallback;
  const { x, y, blur, color, spread } = shadowProperty;
  return `${x}px ${y}px ${blur}px ${spread}px ${color}`;
}
var Overlay = /* @__PURE__ */ forwardRef2(function Overlay2(props, ref) {
  const { layoutType, theme, onDismiss } = props;
  useEffect4(() => {
    const handleKeyDown = (event) => {
      if (event.code === "Escape") {
        event.stopPropagation();
        onDismiss();
      }
    };
    const handlePointerDown = (event) => {
      if (event.pointerType !== "touch") return;
      const isWithinSearchHeader = Boolean(event.target instanceof Element && event.target.closest("[role=search]"));
      if (isWithinSearchHeader) return;
      if (document.activeElement instanceof HTMLInputElement) {
        document.activeElement.blur();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("pointerdown", handlePointerDown, { capture: true });
    document.body.classList.add(bodyOverflowHidden);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("pointerdown", handlePointerDown, { capture: true });
      document.body.classList.remove(bodyOverflowHidden);
    };
  }, []);
  return /* @__PURE__ */ createPortal(/* @__PURE__ */ _jsxs3("div", { ref, className: "__framer-search-modal-container", role: "presentation", style: { ...backdropStyles, zIndex: props.backdropOptions.zIndex, justifyContent: layoutType === SearchLayoutType.Sidebar ? "flex-start" : "center" }, onClick: onDismiss, children: [/* @__PURE__ */ _jsx3(motion3.div, { role: "presentation", initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0, transition: { duration: 0 } }, transition: theme.overlayTransition, style: { top: 0, left: 0, right: 0, bottom: 0, width: "100%", height: "100%", boxSizing: "border-box", position: "absolute", touchAction: "none", backgroundColor: props.backdropOptions.backgroundColor } }), /* @__PURE__ */ _jsx3(SearchModal, { urlScope: props.urlScope, layoutType, inputOptions: props.inputOptions, resultOptions: props.resultOptions, modalOptions: props.modalOptions, backdropOptions: props.backdropOptions, theme: props.theme, onDismiss })] }), document.body);
});
var backdropStyles = { width: "100%", boxSizing: "border-box", willChange: "transform", position: "fixed", display: "flex", alignItems: "flex-start", top: 0, left: 0, right: 0, bottom: 0 };
var containerStyle = { height: "100%", display: "flex", borderRadius: 10, cursor: "inherit", overflow: "hidden" };
var bodyOverflowHidden = "__framer-overflow-hidden";
var EntryPoint = withCSS(function EntryPoint2(props) {
  var _props_inputOptions_inputFont, _props_inputOptions, _props_resultOptions, _props_resultOptions_subtitleOptions, _props_inputOptions1;
  const overlay = useRef3(null);
  const [isOpen, setIsOpen] = useState4(false);
  const [isOverLimit, setIsOverLimit] = useState4(false);
  const [isSafariTouchDevice, setIsSafariTouchDevice] = useState4(false);
  const [isOnCanvas] = useState4(() => RenderTarget.current() === RenderTarget.canvas);
  useEffect4(() => {
    setIsOverLimit(checkIfOverLimit());
    setIsSafariTouchDevice(Browser.isSafari() && Browser.isTouch());
  }, []);
  const baseInputFontSize = ((_props_inputOptions = props.inputOptions) === null || _props_inputOptions === void 0 ? void 0 : (_props_inputOptions_inputFont = _props_inputOptions.inputFont) === null || _props_inputOptions_inputFont === void 0 ? void 0 : _props_inputOptions_inputFont.fontSize) ? props.inputOptions.inputFont.fontSize : "16px";
  const inputFontSize = isSafariTouchDevice ? `max(16px, ${baseInputFontSize})` : baseInputFontSize;
  const layoutType = useViewportSizeState((size) => {
    if (size.width < props.modalOptions.width + 10) {
      return SearchLayoutType.FixedTop;
    }
    return props.modalOptions.layoutType || props.layoutType;
  });
  const theme = {
    subtitleColor: props.resultOptions.subtitleOptions.subtitleColor,
    backgroundColor: props.modalOptions.backgroundColor,
    foregroundColor: props.resultOptions.titleColor,
    placeholderColor: props.inputOptions.placeholderOptions.placeholderColor,
    titleFont: ((_props_resultOptions = props.resultOptions) === null || _props_resultOptions === void 0 ? void 0 : _props_resultOptions.titleFont) && !isEmptyObject(props.resultOptions.titleFont) ? props.resultOptions.titleFont : { fontSize: 14, fontFamily: DEFAULT_FONT_FAMILY, fontWeight: 500 },
    subtitleFont: ((_props_resultOptions_subtitleOptions = props.resultOptions.subtitleOptions) === null || _props_resultOptions_subtitleOptions === void 0 ? void 0 : _props_resultOptions_subtitleOptions.subtitleFont) && !isEmptyObject(props.resultOptions.subtitleOptions.subtitleFont) ? props.resultOptions.subtitleOptions.subtitleFont : { fontSize: 12, fontFamily: DEFAULT_FONT_FAMILY, fontWeight: 500 },
    inputFont: ((_props_inputOptions1 = props.inputOptions) === null || _props_inputOptions1 === void 0 ? void 0 : _props_inputOptions1.inputFont) && !isEmptyObject(props.inputOptions.inputFont) ? props.inputOptions.inputFont : { fontSize: 16, fontFamily: DEFAULT_FONT_FAMILY, fontWeight: 500 },
    // Keep separate so we can more easily override
    inputFontSize,
    width: props.modalOptions.width,
    offsetTop: props.modalOptions.top,
    borderRadius: props.modalOptions.borderRadius,
    shadow: buildShadow(props.modalOptions.shadow),
    entryIconColor: props.iconColor,
    entryIconSize: props.iconSize,
    entryIconImage: props.iconImage,
    inputIconSize: props.inputOptions.iconOptions.iconSize,
    inputIconColor: props.inputOptions.iconOptions.iconColor,
    inputIconImage: props.inputOptions.iconOptions.iconImage,
    gapBetweenStatusAndSearch: 16,
    gapBetweenResults: 1,
    scrollBarWidth: 20,
    margin: 10,
    spacing: 8,
    zIndex: props.backdropOptions.zIndex,
    horizontalSpacing: 20,
    overlayTransition: props.backdropOptions.transition
  };
  const handleClick = (event) => {
    event.preventDefault();
    event.stopPropagation();
    if (isOverLimit) return;
    setIsOpen(true);
  };
  return /* @__PURE__ */ _jsxs3("div", { style: { ...containerStyle, ...props.style, pointerEvents: isOverLimit ? "none" : "auto", opacity: isOverLimit ? 0.4 : 1 }, children: [/* @__PURE__ */ _jsx3("button", { "aria-label": "Search Icon", style: { width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", background: "none", cursor: "inherit", color: "inherit", border: "none", outline: "inherit", padding: 0 }, onClick: handleClick, children: props.iconType === SearchIconType.Custom && theme.entryIconImage ? /* @__PURE__ */ _jsx3("img", { alt: "icon entry point for Site Search", src: theme.entryIconImage.src, width: theme.entryIconSize, height: theme.entryIconSize }) : /* @__PURE__ */ _jsx3(SearchIcon, { color: theme.entryIconColor, width: theme.entryIconSize, height: theme.entryIconSize }) }), /* @__PURE__ */ _jsx3(AnimatePresence, { children: isOpen && !isOnCanvas && /* @__PURE__ */ _jsx3(Overlay, { ref: overlay, layoutType, urlScope: props.urlScope, inputOptions: props.inputOptions, resultOptions: props.resultOptions, backdropOptions: props.backdropOptions, modalOptions: props.modalOptions, theme, onDismiss: () => setIsOpen(false) }) })] });
}, [
  // Prevent scrolling on iOS Safari when Input is focused.
  // From: https://gist.github.com/kiding/72721a0553fa93198ae2bb6eefaa3299
  `
        @keyframes __framer-blink-input {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .__framer-search-modal-container input:focus {
            animation: __framer-blink-input 0.01s;
        }
        `,
  // Allow styling of input placeholder
  `
         .__framer-search-modal-container input::placeholder, 
         .__framer-search-modal-container input::-webkit-input-placeholder { 
            color: var(--framer-search-placeholder-color, #999999);
            opacity: 1;
        }
        `,
  // Allow fallback to 100vh when dvh unit is not supported.
  `
        .__framer-search-modal-container {
            height: 100vh;
            height: 100dvh;
        }
        .__framer-search-modal-container .__framer-max-height-80dvh {
            max-height: 80vh;
            max-height: 80dvh;
        }
        `,
  `
        body.${bodyOverflowHidden} {
            overflow: hidden;
        }`,
  // Increase hit target
  `
        button.__framer-search-clear-button {
            position: relative;
        }
        button.__framer-search-clear-button::after {
            content: "";
            position: absolute;
            top: -10px;
            right: -10px;
            bottom: -10px;
            left: -10px;
        }`
]);
var stdin_default = EntryPoint;
addPropertyControls(EntryPoint, {
  urlScope: {
    title: "Scope",
    // @ts-ignore - Internal
    type: ControlType.PageScope
  },
  // entryType: {
  //     title: "Type",
  //     type: ControlType.Enum,
  //     options: Object.values(SearchEntryType),
  //     optionTitles: Object.values(SearchEntryType).map(titleCase),
  //     displaySegmentedControl: true,
  // },
  iconType: { title: "Icon", type: ControlType.Enum, options: Object.values(SearchIconType), optionTitles: Object.values(SearchIconType).map(titleCase), displaySegmentedControl: true },
  iconColor: { title: "Color", type: ControlType.Color, defaultValue: "#333", hidden: (props) => props.iconType === SearchIconType.Custom },
  iconImage: { title: "File", type: ControlType.ResponsiveImage, allowedFileTypes: ["jpg", "png", "svg"], hidden: (props) => props.iconType === SearchIconType.Default },
  iconSize: { title: "Size", type: ControlType.Number, displayStepper: true, defaultValue: 24 },
  inputOptions: { title: "Input", type: ControlType.Object, buttonTitle: "Icon, Styles", controls: { iconOptions: { title: "Icon", type: ControlType.Object, buttonTitle: "Color, Size", controls: { iconType: { title: "Icon", type: ControlType.Enum, options: Object.values(SearchIconType), optionTitles: Object.values(SearchIconType).map(titleCase), displaySegmentedControl: true }, iconColor: { title: "Color", type: ControlType.Color, defaultValue: "rgba(0, 0, 0, 0.45)", hidden: ({ iconType }) => {
    return iconType === SearchIconType.Custom;
  } }, iconImage: { title: "File", type: ControlType.ResponsiveImage, allowedFileTypes: ["jpg", "png", "svg"], hidden: ({ iconType }) => iconType === SearchIconType.Default }, iconSize: { title: "Icon Size", type: ControlType.Number, displayStepper: true, defaultValue: 18, min: 0, max: 100 } } }, inputFont: {
    title: "Font",
    // @ts-ignore Internal
    type: ControlType.Font,
    displayFontSize: true
  }, textColor: { title: "Color", type: ControlType.Color, defaultValue: "#333" }, placeholderOptions: { title: "Placeholder", type: ControlType.Object, buttonTitle: "Color, Text", controls: { placeholderText: { title: "Text", type: ControlType.String, defaultValue: "Search..." }, placeholderColor: { title: "Color", type: ControlType.Color, defaultValue: "rgba(0,0,0,0.4)" } } }, dividerType: { title: "Divider", type: ControlType.Enum, options: Object.values(SearchInputDividerType), optionTitles: Object.keys(SearchInputDividerType).map(titleCase), defaultValue: SearchInputDividerType.FullWidth }, clearButtonType: { title: "Clear Type", type: ControlType.Enum, options: Object.values(SearchInputClearButtonType), optionTitles: Object.keys(SearchInputClearButtonType).map(titleCase), defaultValue: SearchInputClearButtonType.Icon }, clearButtonText: { title: "Clear Text", type: ControlType.String, defaultValue: "Clear", hidden: (props) => props.clearButtonType !== SearchInputClearButtonType.Text } } },
  modalOptions: { title: "Modal", buttonTitle: "Layout, Width", type: ControlType.Object, controls: { layoutType: { title: "Layout", type: ControlType.Enum, options: Object.keys(SearchLayoutType), optionTitles: Object.values(SearchLayoutType).map(titleCase), defaultValue: SearchLayoutType.QuickMenu }, width: { title: "Width", type: ControlType.Number, defaultValue: 500, min: 200, max: 1e3, displayStepper: true, step: 5, hidden: (props) => props.layoutType === SearchLayoutType.FixedTop }, top: { title: "Top", type: ControlType.Number, defaultValue: 0, min: 0, max: 1e3, displayStepper: true, hidden: (props) => props.layoutType !== SearchLayoutType.FixedTop }, heightIsStatic: { title: "Height", type: ControlType.Boolean, enabledTitle: "Instant", disabledTitle: "Animate", hidden: ({ layoutType }) => layoutType !== SearchLayoutType.QuickMenu }, heightTransition: { title: "Type", type: ControlType.Transition, defaultValue: { type: "spring", stiffness: 800, damping: 60 }, hidden: ({ heightIsStatic, layoutType }) => layoutType !== SearchLayoutType.QuickMenu || heightIsStatic }, borderRadius: { title: "Radius", type: ControlType.Number, defaultValue: 16, displayStepper: true, min: 0, hidden: ({ layoutType }) => layoutType !== SearchLayoutType.QuickMenu }, shadow: { buttonTitle: "Options", type: ControlType.Object, defaultValue: { x: 0, y: 20, blur: 40, spread: 0, color: "rgba(0,0,0,0.2)" }, controls: { color: { type: ControlType.Color, defaultValue: "rgba(0,0,0,0.2)" }, x: { type: ControlType.Number, defaultValue: 0 }, y: { type: ControlType.Number, defaultValue: 20 }, blur: { type: ControlType.Number, defaultValue: 40 }, spread: { type: ControlType.Number, defaultValue: 0 } } }, backgroundColor: { title: "Background", type: ControlType.Color, defaultValue: "#FFF" }, [animationKeyFromLayout(SearchLayoutType.QuickMenu)]: { title: "Animation", type: ControlType.Object, icon: "effect", hidden: ({ layoutType }) => layoutType !== SearchLayoutType.QuickMenu, optional: true, buttonTitle: "Options", controls: {
    opacity: { type: ControlType.Number, defaultValue: 0.5, step: 0.1, min: 0, max: 1 },
    scale: { type: ControlType.Number, defaultValue: 0.75, step: 0.1, min: 0, max: 2 },
    // rotate: {
    //     type: ControlType.Number,
    //     defaultValue: 0,
    //     min: -360,
    //     max: 360,
    // },
    x: { type: ControlType.Number, defaultValue: 0, min: -500, max: 500 },
    y: { type: ControlType.Number, defaultValue: 0, min: -500, max: 500 },
    transition: { type: ControlType.Transition }
  } }, [animationKeyFromLayout(SearchLayoutType.FixedTop)]: { title: "Animation", type: ControlType.Object, icon: "effect", buttonTitle: "Options", hidden: ({ layoutType }) => layoutType !== SearchLayoutType.FixedTop, optional: true, controls: { opacity: { type: ControlType.Number, defaultValue: 0.8, step: 0.1, min: 0, max: 1 }, y: { type: ControlType.Number, defaultValue: 0, min: -100, max: 100 }, transition: { type: ControlType.Transition } } }, [animationKeyFromLayout(SearchLayoutType.Sidebar)]: { title: "Animation", type: ControlType.Object, icon: "effect", buttonTitle: "Options", hidden: ({ layoutType }) => layoutType !== SearchLayoutType.Sidebar, optional: true, controls: { opacity: { type: ControlType.Number, defaultValue: 0.8, step: 0.1, min: 0, max: 1 }, x: { type: ControlType.Number, defaultValue: 0, min: -1e3, max: 1e3 }, transition: { type: ControlType.Transition } } } } },
  resultOptions: {
    title: "Results",
    buttonTitle: "Fonts, Style",
    type: ControlType.Object,
    defaultValue: {},
    // description:
    //     "Learn more about how to use Site Search [here](https://framer.com/learn/site-search)",
    controls: { itemType: { title: "Style", type: ControlType.Enum, options: Object.values(SearchResultItemType), optionTitles: Object.keys(SearchResultItemType).map(titleCase), defaultValue: SearchResultItemType.FullWidth }, titleFont: {
      title: "Title",
      // @ts-ignore - Internal
      type: ControlType.Font,
      defaultValue: { fontSize: 15 },
      displayFontSize: true
    }, titleColor: { title: "Color", type: ControlType.Color, defaultValue: "#333" }, titleType: { title: "Content", type: ControlType.Enum, options: Object.values(SearchResultTitleType), optionTitles: Object.keys(SearchResultTitleType).map(titleCase), defaultValue: SearchResultTitleType.H1, displaySegmentedControl: true }, subtitleOptions: { type: ControlType.Object, title: "Subtitle", buttonTitle: "Font, Content", controls: { subtitleFont: {
      title: "Font",
      // @ts-ignore - Internal
      type: ControlType.Font,
      defaultValue: { fontSize: 13 },
      displayFontSize: true
    }, subtitleColor: { title: "Color", type: ControlType.Color, defaultValue: "rgba(0, 0, 0, 0.4)" }, subtitleType: { title: "Content", type: ControlType.Enum, options: Object.values(SearchResultSubtitleType), optionTitles: Object.keys(SearchResultSubtitleType).map(titleCase), defaultValue: SearchResultSubtitleType.Path } } } }
  },
  backdropOptions: { title: "Backdrop", type: ControlType.Object, buttonTitle: "Color, Z Index", controls: { backgroundColor: { title: "Color", type: ControlType.Color, defaultValue: "rgba(0, 0, 0, 0.8)" }, zIndex: { title: "Z Index", type: ControlType.Number, defaultValue: 10, displayStepper: true, min: 0, max: 10 }, transition: { type: ControlType.Transition } } }
});
EntryPoint.displayName = "Search";

export {
  stdin_default
};
